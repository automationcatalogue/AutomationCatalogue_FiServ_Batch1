OOPS - Object Oriented Programming Structure:
--------------------------------------------
==> Java, Python, C++, JavaScript, C#, Scala, Ruby .... etc.,

OOPS Principles:
----------------
1. Inheritance
2. Polymorphism
3. Abstraction
4. Encapsulation

==> To understand the above 4 principles we should know the language constructs they are
	1. Class
	2. Object
	
CLASS:
------
==> Class is a collection of variables and method

	Syntax:
	-------
	
		class <className>{
		
			public static void test(){
				-----------
				-----------
				-----------
			}
		
			public static void main(String args[]){
				-----------
				-----------
				-----------
			}
			
			public static void qa(){
				----------
				----------
				----------
			}
		
		}
		
	Examples:
	---------
	
		class Emp{
			int empNo;
			float empSalary;
			char empSurName;
			
			void addEmployee(){
				--------
				-------
				-------
			}
			
			void deleteEmployee(){
				-------
				-------
				-------
			}
		
		}
		
		//className: --> Emp
		//methodNames: addEmployee(), deleteEmployee()
		//Variables: empNo, empSalary, empSurName
		
Object:
-------
==> Object is a instance of class

	Syntax:
	-------
		className objectReference = new Constructor();
		
	Example:
	-------
		Emp ob1 = new Emp();
		
		//ob1 --> ObjectReference --> contains the hashcode --> reference of your data
		//new Emp(); --> Object --> Contains the data
		
		new Emp();--> Anonymous Object
		
Variables:
---------
==> Variable is a container which contains some data

1. Instance Variables
2. Class Variables
3. Local Variables


Instane Variables:
------------------
==> A variable i.e., declared as a member of a class is known as Instance variable
==> Instance variables memory allocation happens whenever object is created
==> Instance variables are stored in heap are memory

Class Variables:
----------------
==> A variable i.e., declared as a static member of a class is known as class variable
==> Class variables memory allocation happens whenever class is loaded
==> class variables are stored in method area memory

Local Variables:
----------------
==> A variable i.e., defined inside a method is called as Local Variable
==> Local variable memory allocation happens whenever method is called
==> Local variables are stored in Stack area memory

Execution Priority:
-------------------
1. Class Variables
2. main method

Note:
1. Local variables can not be static in Java
2. There is no global variables concept in java


In Java, Instance variables can be accessed in '2' ways
1. By using Object
2. By using ObjectReference

==> Use Object to access an instance variable if it is required only one time
==> User Object Reference to access an instance variable if it required more than one time


In Java, there are '4' to access the class variable
1. Directly
2. By using ClassName
3. By using Object
4. By using ObjectReference
	
	Both Object and ObjectReference are not recommended to use
	
==>Access the class Variable directly if it is present in the same class
==>use classname to access class variable if it is present in different class
	
	
In Java, there is only one way to access the Local variable i.e., Directly

==>Use className to access class variable whenever both class variable and Local variable names are same


==> Only one copy of class variables exists for all objects
==> Separate copy of instance variables exists for every object

public class VarDemo1 {
    int x=5;//instance variable
    static int y=10;//class variable

    public static void main(String[] args) {
        VarDemo1 ob1 = new VarDemo1();
        VarDemo1 ob2 = new VarDemo1();

        ob1.x = ob1.x+2;
        ob1.y = ob1.y+2;

        System.out.println(ob1.x);
        System.out.println(ob1.y);
        System.out.println(ob2.x);
        System.out.println(ob2.y);
    }
}


=====================================================================================
class Emp{											class Emp{
	int empNo;											int empNo;
	float empSalary;									static float empSalary;
}													}

													empSalary=1000 --> 4 bytes
Emp ob1 = new Emp();								Emp ob1 = new Emp();
ob1 --> empNo, empSalary --> 8 bytes				ob1 --> emNo --> 4 bytes

Emp ob2 = new Emp();								Emp ob2 = new Emp();
ob2 --> empNo, empSalary --> 8 bytes				ob2 --> empNo --> 4 bytes

Emp ob3 = new Emp();								Emp ob3 = new Emp();
ob3 --> empNo, empSalary --> 8 bytes				ob3 --> empNo --> 4 bytes

----------------------------						---------------------
----------------------------						---------------------
----------------------------						---------------------

Emp ob100 = new Emp();								Emp ob100 = new Emp();
ob100 --> empNo, empSalary --> 8 bytes				ob100 --> empNo --> 4 bytes

800 bytes											400 + 4 bytes --> 404 bytes


==> Use the Instance variable, if value is changing for every object
==> Use the class variable, if value is same for all objects/every object
==> Use the Local variable, whenever some action is performed


Garbage Collector:
------------------
==> Garbage means unused objects

//Garbage Collector:
--------------------
==> It is the JVM component and it collects the garbage whenever CPU gets free time. because garbage collector priority is least priority
==> priority number is '1'

==> It is also possible to call garbage collector explicitly by using gc() method of java.lang.System class

class Demo{
	int x=5; 
	int y=10;
	public static void main(String args[]){
		Demo ob1 = new Demo();
		Demo ob2 = new Demo();
		Demo ob3 = new Demo();
		
		---------------
		---------------
		---------------
		ob1=null;
		
		--------------
		--------------
		--------------
		ob2=ob3;
	}
}

int x;//Declaration
x=10;//Assignment
int x=10;//initialization


Arrays:
-------
==> An array is a collection of similar data elements

==> An array index always strts  with '0' and ends with size-1


1. Declaration:
----------------
	Syntax:
		DataType arrayRef[] = new DataType[size];
		
	Example:
		int a[] = new int[10];
2. Assignment:
--------------
	Syntax:
		arrayRef[index] = literal;
		
	Examples:
		a[0]=72;
		a[2]=98;
		
3. Initialization:
-------------------
	Syntax:
		Datatype arrayRef[]={literal1, literal2, literal3, literal4,......};

	Example:
		int a[]={72,45,500,68,95};
		
Advanced For Loop/Enhance For Loop/For Each Loop:
-------------------------------------------------

	Syntax:
	-------
		for(DataType variableName:arrayRef){
			--------------
			--------------
			--------------
		}
		
	Examples:
	---------
		for(int b:a){
			------------
			------------
			------------
		}
		
METHODS:
--------
==> Method is a group of statement into a single logical unit

Advantages:
----------
1. Reusability
2. Modularity

==> There are '2' types of methods in Java
1. Instance Method
2. Class Method

Instance Method:
----------------
==> A method that is defined as a member of a class is known as Instance method

There are 2 ways to access Instance method
	1. By using Object
	2. By using Object Reference
	
Class Method:
-------------
==> A method that is defined as a static member of a class is known as class method
There are 4 ways to access class methods
	1. Directly
	2. By using Class Name
	3. By using Object
	4. By using Object Reference
	
1. Method Definition --> Actual Logic will be called
2. Method call Statement --> This is a statement to execute your block of code

==> Both Instance Method and Class Methods are divided into '4' Categories
1. Method without return type and without arguments
2. Method without return type and with arguments
3. Method with return type and without arguments
4. Method with return type and with arguments


1. Method without return type and without arguments:
----------------------------------------------------
	Syntax:
		
		//Method definition - Instance Method
		void methodName(){
			------------
			------------
			------------
		}
		
		//ob1.methodName(); - Method Call Statement
		
2. Method without return type and with arguments
-------------------------------------------------
	Syntax:
	
		void methodName(DataType1 var1, DataType2 var2, DataType3 var3,......................DataType varN){
			---------------------
			---------------------
			---------------------
		}
		
		Examples:
			
			void print(int x, float y, char ch){//method definition
				--------
				--------
				--------
			}
			
			ob1.print(10, 45.23f, 'G');//method call statement
			
3. Method with return type and without arguments:
--------------------------------------------------

	DataType methodName(){
		-------------
		-------------
		------------
		
		return value;
	}
	
4. Method with return type and with arguments:
-----------------------------------------------

	DataType methodName(DataType1 var1, DataType2 var2, DataType3 var3,......................DataType varN){
		----------------------
		----------------------
		----------------------
		
		return value;
	}
	
==>In Method definition, if there is a return value, then that method must return it, otherwise compilation Error will come
==>If Method definition is returning some value, method call statement may take the value or not. there will be no compilation Error even if it don't take
==> However method is defined with some arguments, same way we must pass the number of arguments in method call statement.

this Keyword:
-------------
==> It is called as an Object Reference because it refers an object
==>It always refers the current object and it is implicitly present in Instance method

    int x=5;

    public static void main(String[] args) {
        Demo1 ob1 = new Demo1();
        ob1.show();
    }

    void show(){
        System.out.println(x);
    }
	
	
public class Demo1 {
    int x=5;

    public static void main(String[] args) {
        Demo1 ob1 = new Demo1();
        Demo1 ob2 = new Demo1();
        ob1.x = ob1.x+2;
        ob1.show();
        ob2.show();
    }

    void show(){
        System.out.println(this.x);
    }
}

==> this keyword must be written explicitly whenever both instance variable and local variable names are same
==> Static method does not refer 'this' keyword in any way (Either implicitly or explicitly)


CONSTRUCTOR:
------------
==> Constructor is a special method which has the same name as a class name and which has no retun type
==> constructor is called automatically whenever an object is created
==> Constructors are used to initialise the instance variables

==> Constructors are '2' types
	1. Default constructor [without arguments]
	2. Parameterized constructor [with arguments]
	
	
1. 
class Demo{
	Demo(){//Constructor
		-------
		-------
		-------
	}
}

2. 
class Demo{
	demo(){//Not a valid constructor
		-------
		-------
		-------
	}
}

3. 
class Demo{
	void Demo(){//method, but it is not following java standards
		-------
		-------
		-------
	}
}
 
4. 
class Demo{
	void demo(){//valid method
		-------
		-------
		-------
	}
}

==> this() --> It calls default constructor of current class
==> this(DataType1 var1, DataType2 var2,.....) --> It calls Parameterized constructor of a current class

Note:
==> this(); or this(arg1, arg2, arg3,.....argN); --> must be a first statement in the constructor


==> Constructors are used to initialise the instance variables

==> Whenever object is created memory allocation happens to instance variables
==> Constructors are automatically executed  whenever object is created


int x=10;//initialization

int x;//definition
x=10;//Assgnment

==> Differences b/w Constructor and Methods:
--------------------------------------------
	Constructor																Methods
1. constructor is not having any return type							1. method must have return type [without return type means void should be written]
2. Constructor is a special method, which has same name					2. Methods is a group of statements into a sing
as the className
3. Constructors are automatically wheneverobject is created				3. Methods must be called explicitly after creating the object
4. Constructors are used to initialize the instance variables			4. Methods are used to perform some task
5. Constructor is called only one time for one object					5. Methods can be called any number of time for one object

Note:
==> If the class does not contain any constructor, then only system will provides one default constructor implicitly

1. 
class Demo{
	//Demo(){} --> System provided default constructor implicitly
	public static void main(String args[]){
		Demo ob1 = new Demo();
	}
}

2. 
class Demo{
	//Demo(){} --> System provided default constructor implicitly
	public static void main(String args[]){
		Demo ob1 = new Demo(5); // Error will come as there is no Parameterized constructor is written
	}
	
}

3. 
class Demo{//valid
	Demo(int x){
		-------
		-------
		-------
	}
	public static void main(String args[]){
		Demo ob1 = new Demo(5);
	}
}

4. 
class Demo{
	Demo(int x){
		-------
		-------
		-------
	}
	public static void main(String args[]){
		new Demo();
	}
}

OOPS Principles:
----------------
1. Inheritance
2. Polymorphism
3. Encapsulation
4. Abstraction

Inheritance:
------------
==> Creating a new class from an existing class is called as Inheritance
==> Newly created class is called as 'sub class' (or) 'child class'
==> Existing class is called 'super class' (or) 'parent class'


class student{  //Super class

	int rollNo;
	String name;
	long landlineNumber;
	char gender;
	
	-------------
	-------------
	-------------
}

class student1 extends student{ //Sub Class
	long mobileNo;
	String emailID;
	
	------------
	------------
	------------
}

==> 'extends' is a keyword to make a relationship between two different classes

==> Whenever object is created for super class, memory allocation happens for only super class members
==> Whenever object is created for sub class, memory allocation happens for both super class members and sub class members

Types of Inheritance:
---------------------
1. Single Inheritance
2. Multiple Inheritance
3. Multilevel Inheritance
4. Hierarchial Inheritance
5. Multipath Inheritance
6. Hybrid Inheritance

Single Inheritance:
-------------------
==>Derivation of a class from only one super class is known as Single Inheritance
		A//Super class
		|
		B//sub class
		
Multiple Inheritance:
----------------------
==>Derivation of a class from more than one super class is known as Multiple Inheritance

		A           B
		|			|
		-------------
			|
			C
			
Multilevel Inheritance:
-----------------------
==> Derivation a class from Sub class is called as Multilevel Inheritance
		A
		|
		B
		|
		C
		
Hierarchial Inheritance:
------------------------
==> Derivation of several classes from only super class is called as Hierarchial Inheritance
			A//Super class
			|
		---------
		|	|	|
		B	C	D//sub classes
		
Multipath Inheritance:
----------------------
==> Derivation a class from more than one sub class and these subclasses are derived from same super class is called as Multipath Inheritance
						A
						|
					----------
					|		|
					B		C
					---------
						|
						D
						
Hybrid Inheritance:
-------------------
==> Derivation of a class involving more than one form of Inheritance is called as Hybrid Inheritance
			A
			|
			B	C
			|	|
			-----
			  |
			  D
	Note: Multipath Inheritance can also example of Hybrid Inheritance

Note: Java doesn't support Multiple Inheritance, Multipath Inheritance and Hybrid Inheritance

		A show()          B show()
		|				  |
		------------------
			|
			C 
	==> C ob1 = new C();
	ob1.show()
==>Java doesn't support multipath Inheritance and Hybrid Inheritance because both types contains multiple Inheritance


public class A1 {
    int x=5;//instance variable

    void primeLogic(int n){
        int count=0;
        for(int i=1;i<=n;++i){
            if(n%i==0){
                ++count;
            }
        }
        if(count==2){
            System.out.println("Given number is Prime!!!");
        }else{
            System.out.println("Given number is not Prime!!!");
        }
    }
}

public class B1 extends A1{
    int y=10;

    int factLogic(int x){
        int fact=1;
        for(int i=x;i>=1;--i){
            fact = fact * x;
        }
        return fact;
    }
}

public class Test1 {
    public static void main(String[] args) {

    }
}

==>Super class ObjectReference can refer only super class members
==>Super class ObjectReference cannot refer subclass members data

==>Sub class ObjectReference cannot refer the Supeclass Object

==> Super class ObjectReference can refer both super class Object and Sub class Objects, but it can access only super class members data
	A1 ob1 = new A1();
	A1 ob3 = new B1();

==> Sub class ObjectReference can refer only subclass object, but it can access both super class and sub class members data
	B1 ob2 = new B1();


Super Keyword:
--------------
==> Super is a keyword in Java, it is called as Object Reference because it refers the Super class memory
==>It is explicitly required to access the super class member, whenever both super class and sub class member names are same.

Note:
-----
	Static method does not refer this and super keywords in anyway either implicitly or explicitly
	
	
super(); (or) super(arg1, arg2, arg3, arg3......);
Super();
	--> this statement calls default constructor of super class, it is implicitly present as a first statement in every constructor.
super(arg1, arg2, arg3, arg3......);
	--> this statement calls parameterized constructor of super class
	
public class X {
    //Default Constructor
    X(){
        this(10,20);
        System.out.println("Core Java");
    }

    //Parameterized constructor
    X(int a, int b){
        int c=a+b;
        System.out.println("Sum of a, is :"+c);
    }
}

public class Y extends X{
    //Default constructor
    Y(){
		//super();
        System.out.println("Advanced Java!!!");
    }

    Y(int a, int b){
        this();
        int c=a*b;
        System.out.println("Multiplication of a, b is :"+c);
    }
}

public class Test3 {
    public static void main(String[] args) {
        Y ob1  = new Y(10,20);
    }
}

Final Keyword:
--------------
==> final keyword is called as modifier, because it modifies the behaviour of a variable,class and method.
==> By using final keyword we can prevent the value of a variable, method over riding and Inheritance

	final int x=5;	
		x++;-->Error because final values can not be changed
		
==> final keyword is applicable for all variables (Instance variable, class variable, local variable)
==> final variable must be initialized, otherwise compile time error occurs.

class Demo{
	final int x;
	Demo(){
		x=10;
	}
	public static void main(String args[]){
		System.out.println(new Demo().x);
	}
}

Access Modifiers (or) Access Specifiers:
----------------------------------------
==> Access modifiers are also called as Access specifiers, because they specify the permissions for a variables, methods, classes, interfaces, packages etc.,

==> There are '4' types access modifiers in Java
1. public   --> Visibility across the project
2. private --> Visibility is only within class
3. protected --> Visibility is only with in package and outside the package classes must be inherited
4. no name[Default] --> Visibility is within package

Order of more restrictive to less restrictive modifiers:
---------------------------------------------------------
private --> No Name[Default] --> Protected --> Public

Polymorphism:
-------------
==> Ability to take more than one form is called as Polymorphism
==> Here poly means 'many' and morphism means 'forms'

==> In Java, Polymorphism can be implemented in '2' ways
1. Compiletime Polymorphism [Static Binding]
2. Runtime Polymorphism [Dymanic Binding]

Compiletime Polymorphism:
-------------------------
==> Binding of method call statement with medthod definition is done at compile time is known as 'compile time polymorphism'
Example: Method Overloading

Method Overloading:
------------------
==> If two (or) more methods with same name and with different parameters list, then it is said to be method overloading
==> There are '3' ways to overload the methods
1. Different in Number of Arguments
	void add(int a){
	
	}
	void add(int a, int b){
	
	}
2. Different in Datatypes
	void add(int a, int b){
	
	}
	
	void add(float a, float b){
	
	}
	
3. Different in Order of arguments
	void add(int a, float b){
	
	}
	
	void add(float a, int b){
	
	}
	
Runtime polymorphism:
---------------------
==> Binding of method call statement with medthod definition is done at Runtime is known as 'Runtime polymorphism'
Ex: Method Overriding

Method Overriding:
------------------
==> If two (or) more methods with same name and same parameters list, then it is said to be method overriding.
Note: 1. Method Overriding is not possible within the same class
2. Method overriding is possible only within the Inheritance


=> Whenever object is created for sub class, subclass method is going to replace in super class during the runtime, when both superclass and subclass method names are same.

public class A {//super class
    //instance - method definition
    void print(int x){
        if(x%2==0){
            System.out.println("Given number x is Even!!! "+x);
        }else{
            System.out.println("Given number x is Odd!!! "+x);
        }
    }

    void cube(int a){
        int b=a*a*a;
        System.out.println("Cube of the given number is :"+b);
    }
}

public class B extends A{//subclass
    void print(int x){
        int count=0;
        for(int i=1;i<=x;++i){
            if(x%i==0){
                ++count;
            }
        }
        if(count==2){
            System.out.println("Given number is Prime!!!");
        }else{
            System.out.println("Given number is Not Prime!!!");
        }
    }

    void fact(int y){
        int fact=1;
        for(int i=y;i>=1;--i){
            fact=fact*y;
        }
        System.out.println("factorial of a number is:"+fact);
    }
}

public class Test {
    public static void main(String[] args) {
        
    }
}

Differences between Method Overloading vs Method Overriding:
-------------------------------------------------------------
		Method Overloading										Method Overriding
1. If two (or) more methods having same name 				1. If two (or) more methods having same name and same parameters 
different in parameters list is known as Method					list is known as Method overriding
Overloading

2. Method overloading can be possible in same class			2. Method Overriding can not be possible in the same class
3. Method Overloading is possible without Inheritance also  3. Method overriding is possible only with Inheritance
4. It is a Compiletime Polymorphism							4. It is a example of Runtime Polymorphism
5. In Method overloading return type can be same 			5. In Method overriding return type must be same except 
(or) different													co-variant return type
6. In Method overloading, Access modifiers can be same 		6. In Method overriding, Access Modifiers must be same (or)
(or) different													less restrictive
7. final Methods can be overloaded							7. final Methods cannot be overridden
8. Static Methods can be overloaded							8. Static Methods cannot be overridden
9. Private methods can be overloaded						9. Private methods cannot be overridden
1. 
class Demo{
	void add(int a, int b){ //valid method overloading
		---------
		---------
	}	
	
	void add(int a, int b, int c){
		---------
		---------
	}
}

2. 
class Demo(){
	void add(int a, int b){	//valid method overloading
		--------
		--------
	}		
}
class Test extends Demo{
	float add(float a, float b){
		--------
		--------
	}
}

3. 
class Demo(){			
	void add(int a, int b){	//valid method overriding
		--------
		--------
	}		
}
class Test extends Demo{
	void add(int a, int b){
		-------
		-------
	}
}

4. 
class Demo{
	void get(){ //Invalid method overriding, because return type must be same (or) co-variant return type
		-------
		-------
	}						
}
class Test extends Demo{
	int get(){
		-------
		-------
	}
}

Co-Variant Return type:
----------------------
==> Java permits subclass type as a return type while overriding a method. This is known as co-variant return type

class Demo(){
	Demo get(){
		-------
		-------
	}
}								
class Test extends Demo{
	Test get(){
		--------
		--------
	}
}


6.
class Demo{
	protected void show(){	//Valid method overriding
		-------------
	}
}
class Test extends Demo{
	public void show(){
		--------------
	}
}

7. 
class A{
	final void show(){//Invalid method overriding, final keyword can not be overridden
	
	}
}
class B{
	void show(){
	
	}
}

8.
class A{
	final void show(){//Invalid, because final keyword prevents method overriding
	
	}
}
class B{
	final void show(){
	
	}
}

9.
class A{
	void show(){//valid method overriding
	
	}
class B extends A{
	final void show(){
	
	}
}

10.
class A{
	void show(){//Invalid, static methods can not be overridden
		----------
		----------
	}
}
class B extends A{
	static void show(){
		---------
		---------
	}
}

11.
class A{
	static void show(){ //valid, but not the concept of overriding. It is called as method hiding
		----------
		----------
	}
}
class B extends A{
	static void show(){
		---------
		---------
	}
}

Method overriding					Vs					Method Hiding
-------------------------------------------------------------------------
class A{												class A{
	void show(){											static void show(){
		s.o.p("Core Java");										s.o.p("Core Java");
	}														}
															
															static void print(){
																-------------
															}
}														}
class B extends A{										class B extends A{
	void show(){											static void show(){
		s.o.p("Advanced Java");									s.o.p("Advanced Java");
	}														}
															
															static	void display(){
																-------------
															}											
	
	
	public static void main(String args[]){					public static void main(String args[]){
		A ob = new B();											A ob = new B();
		ob.show();												ob.display();
																ob.print();
																ob.show();
	}														}
}														}

o/p: Advanced Java										o/p: Core Java

In the above example 'A' class show() method			In the above example one show() method is available for object reference and one more show() method 	
overidden by 'B' class show() method					is hidden. This is known as Method Hiding

class A{
	private void show(){//Invalid Method overriding
		----------
		----------
	}
}
class B extends A{
	void show(){
		----------
		----------
	}
}

Abstraction:
------------
==> Providing necessary information and hiding unnecessary information is known as Abstraction
==> In Java, anstraction can be implemented by using abstract class and interface

abstract class:
---------------
==> A class i.e., declared with abstract keyword is known as Abstract class
==>Abstract class can have only abstract methods (or) only non-abstract methods (or) combination of both abstract and non-abstract methods 

Abstract method:
----------------
==> A method which has no body is called as abstract method
==> Abstract method must be declared with abstract keyword in Java, otherwise compile time error occurs

Non-Abstract (Concrete) method:
-------------------------------
==> A method which has body is called as Non-Abstract method

==>If the class contains abstract method, then the class must be declared with abstract keyword, otherwise compile time error occurs.

==>void show(){//Non-abstract method
	----------
	---------- 
	----------
}

==> abstract void show();//abstract method

==> void show(){}//Null Body method
-->Null body method is also called as Non-Abstract method

==> 
abstract class A{
	void show(){//valid
		-------
	}
	void print(){
		-------
	}
}	
==>
abstract class B{
	void show(); //Invalid, abstract method should have 'abstract' keyword
	void print();

==>
abstract class C{
	abstract void show();//valid
	abstract void print();
	
}	

==>
class D{
	void show(){}
	abstract void print();//Invalid, abstract methods can not be written in regular class
}

==>
abstract class E{
	abstract void show();//valid
	void print(){}
}	

==>Abstract class can not be instantiated i.e., object can not be created

==>Abstract class can be Inherited by using 'extends' keyword

==> Whenever abstract class is Inherited, then all abstract methods of an abstract class must be overridden in a sub class	
		(OR)
	Subclass must be declared with abstract keyword, otherwise compile time error occurs.

abstract public class Demo {
    //abstract method
    abstract void show();

    //Non-abstract method
   void prime(int x){
       int count=0;
       for(int i=1;i<=x;++i){
           if(x%i==0){
               ++count;
           }
       }
       if(count==2){
           System.out.println("Given number "+x+ " is a Prime!!!");
       }else{
           System.out.println("Given number "+x+ " is not a Prime!!!");
       }
   }

}

public class Test extends Demo{
    void show(){
        int a=10, b=20;
        int c=a+b;
        System.out.println("Addition of a, b is :"+c);
    }

    void fact(int x){
        int fact=1;
        for(int i=x;i>=1;--i){
            fact = fact*i;
        }
        System.out.println("Factorial of a given number is :"+x);
    }
}

public class sample {
    public static void main(String[] args) {

    }
}

interface:
----------
==> interface is a collection of public static final variables and public abstract methods
==>In interface all variables are implicitly public static final and all methods are public abstract

==> Every interface itself implicitly abstract
interface A{						abstract interface A{
	int x=5;							public static final int x=5;
	void show();			<===>		public abstract void show():
}									}

==> Interface can not be instantiated ie., so we can not create an object to an interface
==> Interface can be inherited into a class by using 'implements' keyword

==>Whenever interface is inherited into a class all methods of an interface must be overridden in a sub class
	(OR)
	Subclass must be declared with abstract keyword, otherwise compile time error occurs
	
public interface Demo1 {

    int x=10;    //public static final int x=10;
    void show(); //public abstract void show();
}

public class Test1 implements Demo1{

    int y=10;//instance variable

    public void show(){
       int x=5;
       int y=x*x*x;
        System.out.println("Cube of the given number is :"+y);
    }
	
	void display(){
        System.out.println("Advanced Java!!!");
    }

}

public class Sample1 {
    public static void main(String[] args) {

    }
}
==> Class can not be inherited into interface

1) 
	class A{ //valid
		---------
		---------
		---------			
	}
	class B extends A{
		---------
		---------
		---------
	}
	
2)
	interface A{//valid
		--------
		--------
		-----
		-----
	}
	class B implements A{
		--------			
		--------
		--------
	}
	
3) 
	interface A{//valid
		-------
		-------
		-------
	}
	interface B extends A{
		------				
		------
		------
	}

4) class A{//Invalid
		------
		------
	}						
	interface B --- A{
		------
		------
	}
	
Note: Java doesn't support Multiple Inheritance, Multipath Inheritance and Hybrid Inheritance
			A show()		B show() 		
			|				|
			-----------------
					|
					C
			C ob=new C();
			-->ob.show(); --> This statement  gives ambiguity to call either A class show() method or B Class show() method.
			
==> Interfaces are introduced in java to achieve the muliple inheritance

			A show()- Interface			B show() 		
			|							|
			-----------------------------
					|
					C show();
					
	Class A{
		--------
		--------
	}
	class B{
		--------
		--------
	}
	interface C{
		--------
		--------
	}
	interface D{
		-------
		-------
	}
	
	class E extends A, B{//Invalid
	
	}
	
	class F implements C, D{//valid
	
	}
	
		C show()			D show()
		|					|
		---------------------
				|
				F show()
			F ob = new F();
			ob.show();
			
	class G extends A implements C{}//valid
		A show(){----}		C show();
		|					|
		---------------------
				|
				G show();
			G ob = new G();
			ob.show();
			
	class H extends A implements C, D{}//valid
	
	interface i extends C, D{}
	
abstract method:
----------------
==> A method which has no body is called as abstract method.
==> abstract method allows to declare a method in abstract class (or) interface and allows to define in its sub classes with multiple definitions.

										A show()
										|
						------------------------------------------------
						|					|				|			|
						B show()			C show()		D show()	E show()
						EvenOdd				 prime()		fact()		cube()
						
						
						A ob = new B();
						ob.show(); --> even
						
						A ob = new C();
						ob.show();--> prime
						
						A ob = new D();
						ob.show(); --> fact
						
						A ob = new E();
						ob.show();
						
==> abstract class supports 0 to 100 % abstraction whereas interface supports only 100% abstraction

Encapsulation:
--------------
==> Binding of variables with methods and those methods are operating on same variables, this is known as Encapsulation.
class Person{
	private int age;
	
	void setAge(int age){
		if(age>100){
			this.age=100;
		}else if(age<0){
			this.age=0;
		}else{
			this.age=age;
		}
	}
	int getAge(){
		return age;
	}
}
class Demo{
	public static void main(String args[]){
		Person p = new Person();
		p.age=-200;
	
		System.out.println(p.getAge());
	}
}

==> In the above example 'age' variable bounds with setAge() and getAge() methods and those methods are operating on age variable. This is known as Encapsulation

Inner Classes:
--------------
==> A class within the another class, it is known as Inner class
==> There are '4' types of Inner classes
	1. Member Class
	2. Static Member Class (Nested top level class)
	3. Local Class
	4. Anonymous Class (It is one type of other class)
	
1. Member class:
----------------
==> A class i.e., declared as a member of another class is known as member class
Syntax:
	OuterClass.InnerClass objectReference = OuterClassObjectReference.new InnerClassName();

public class A {
	void print(){
		System.out.println("Advanced Java...!!!");
	}
	class B{
		
		void show(){
			System.out.println("Hello World...!!!");
		}
		
		/*static void display(){
			System.out.println("Core java...!!!");
		}*/
	}
}

public class Demo {
	
	public static void main(String args[]){
		A ob1 = new A();
		ob1.print();
		
		A.B ob2 = ob1.new B();
		ob2.show();		
	}

}

Note: In a Member class, only Instance methods are possible and static methods is not possible (must be written in a Nested top level class)
						
2. Static Member Class (Nested top level class):
-------------------------------------------------
==>A class i.e., defined as a static member of another class is known as static member class
Syntax:
	
	OuterClass.InnerClass ObjectReference = new OuterClass.InnerClass();
	
public class X {

    int l=10;

    void show(){
        int a=10,b=20;
        int c=a+b;
        System.out.println("Addition of a,b is :"+c);
    }


    static class Y{
        int m=20;
        static int n=30;
        void display(){
            int a=10;
            if(a%2==0){
                System.out.println("Given number is Even!!!");
            }else {
                System.out.println("Given number is Odd!!!");
            }
        }

        static void print(){
            int a=5;
            int b=a*a*a;
            System.out.println("Cube of the given number is :"+b);
        }
    }

}

public class Test1 {
    public static void main(String[] args) {
        X ob1 = new X();
        System.out.println(ob1.l);
        ob1.show();

        X.Y.print();
        X.Y ob2 = new X.Y();
        ob2.display();
        System.out.println(ob2.m);
        System.out.println(X.Y.n);
    }
}

3. Local Class:
---------------
==> A class i.e., defined inside a method is known as Local class
public class Z {
	
	public static void main(String[] args) {
		
		class Test{//Local class
			
			void show(){
				System.out.println("Hello World...!!! and this is local class demo");
			}
			
		}

		Test ob = new Test();
		ob.show();
	}
	
}
	
4. Anonymous Class (It is one type of other class):
-----------------------------------------------------
==> It is one type of local class which has no name.
==> It is always sub class of a class (or) interface

public interface C {
    void show();//public abstract void show();

    void display();
}

public class Demo {
    public static void main(String[] args) {
        C ob1 = new C(){
            public void show(){
                System.out.println("Core Java");
            }
            
            public void display(){
                System.out.println("Advanced Java");
            }
        };

        ob1.show();
    }
}
	
	
		C ob1 = new C(){														class  ________ implements C{
            public void show(){														public void show(){
                System.out.println("Core Java");										System.out.println("Core Java");
            }															<==>		}
            
            public void display(){													public void display(){
                System.out.println("Advanced Java");									System.out.println("Advanced Java");
            }																		}
        };																		};
		
		ob.show();														<==>	C ob1 = new _____C();
		
String Handling:
----------------
==>"Java API Documentation 8" --> Search in Google
To get all the packages, sub packages, classes, Interfaces, methods, variables, etc.,

String Handling:
----------------
There are '3' String related classes to handle the Strings
1. java.lang.String
2. java.lang.StringBuffer
3. java.lang.StringBuilder

//Constructors
  public String(); // This consuctor will create a Empty String
  public String(String);// This Constructor will create some String
  public String(char[]); -->  This Constructor is used to convert the given char array into String
  public String(byte[]); --> This Constructor is used to convert the given byte array into String
  public String(StringBuffer); --> This Constructor is used to convert the StringBuffer Class ObjectReference to String class
  public String(StringBuilder); --> This Constructor is used to convert the StringBuilder Class ObjectReference to String class
  
//Methods
  public int length();// This method is used to get the length of the given String
  public boolean isEmpty(); --> This method is used to check whther the given String is empty or not
  public char charAt(int); --> This method is used to get the character of a String for specific index position
  public byte[] getBytes();> This method is used to conver the given String into th byte array
  public boolean equals(String);  --> This methid is used to verify both the Strings are same or not
  public boolean equalsIgnoreCase(String); This methid is used to verify both the Strings are same or not by ignoring case sensitivity
  public boolean startsWith(String, int); --> This method is used to check given String value starting at specific index
  public boolean startsWith(String);--> This method is used to check whther given String is startsWith the another String
  public boolean endsWith(String); --> This method is used to check given String ending with some specific String
  public int hashCode();
  public int indexOf(String); --> This method is used to get the index position of the first occurance of given String
  public int indexOf(String, int);  --> This method is used to get the index position of the first occurance of given String starting from the given index position
  public int lastIndexOf(String); --> This method is used to get the index position of the last occurance of given String
  public int lastIndexOf(String, int); --> This method is used to get the index position of the last occurance of given String
  starting from the given index position
  public String substring(int); --> This method is used to get the SubString of a String from starting of the index position
  public String substring(int, int); --> This method is used to get the SubString of a String from starting of the index position to ending position-1
  public String concat(String); --> This method is used to concatenates the two Strings data
  public String replace(char, char);  --> This method is used to convert the given character with another character
  public boolean contains(CharSequence); --> This method is used to check given String contains the original charSequence
  public String replaceFirst(String, String); -> This method is used to replace the first occurance of String with the new String
  public String replaceAll(String, String); -> This method is used to replace the every occurance of String with the new String
  public String replace(CharSequence, CharSequence); --> This method is used to replace the every occurance of Character with the new String
  public String[] split(String, int); --> This method is used to split the given String into the String array after some index position
  public String[] split(String); --> This method is used to split the given String into the String array
  public String toLowerCase();  --> This method is used to conver the given String into lowercase alphabets
  public String toUpperCase(); --> This method is used to convert the given String into uppercase alphabets
  public String trim();  --> This method is used to trim the extra spaces at the begining of String and ending of String
  public String toString();  --> This method will give the content of the String
  public char[] toCharArray(); --> This method is used to convert the given String into a Character array   
  public static String valueOf(char);--> This method is used to convert the char value to String
  public static String valueOf(int); --> This method is used to convert the int value to String
  public static String valueOf(long); --> This method is used to convert the long value into String
  public static String valueOf(float); --> This method is used to convert the float value to String
  public static String valueOf(double); --> This method is used to convert the double value to String
  
  
==> There are '2' ways to create a Object for String Class
	1. String s1 = new String("Hello India");
			(or)
	2. String s1 = "Hello India";
  
==> java.lang.Object is a super class for all java classes
==> java.lang.Object is implicitly inherited in every class

1)
class Demo extends Object{//Implicitly presents
	--------
	--------
	--------
}


2)

Class A extends Object{//Implicitly presents
	--------
	--------
	--------
}

Class B extends A{
	--------
	--------
	--------
}

==> Every String literal itself is a object in String class

String s1 = "Hello India";
	This statement Creates one object in String Constant Pool
	
	
	
String Constant Pool:
---------------------
==> It is one of the memory segment in the RAM
==> In String Constant Pool, Only String related data will be stored
==> For better performance of the execution, this memory point will be used
==> It is going to take less memory Usage as it does not allow duplicate values

public class Demo16 {
    public static void main(String[] args) {
        String s1 = "Hello India";
        String s2 = "Hello India";
        System.out.println(s1.equals(s2));//true
        System.out.println(s1==s2);//true

        String s3 = new String("Hello India");
        String s4 = new String("Hello India");
        System.out.println(s3.equals(s4));
        System.out.println(s3==s4);
    }
}

==> Equals method of String class compares contents of String Object
==> Equals operator compares the hashcode
==> Equals method of Object class compares hashcode


==> Whenever Object (or) Object reference is passed as a parameter in a method, then implicitly "toString()" method is called
==> String class "toString()", method always returns the content of the String
==> Object class "toString()", method is always returns the classname@hashcode-in hexa decimal format


Difference b/w String, String Buffer, String Builder:
----------------------------------------------------
String													StringBuffer												StringBuilder
1. The object of String class is immutable				1. the object of StringBuffer class is mutable				1. The object of StringBuilder class is mutable
2. The methods of String class are not synchronized		2. The methods of StringBuffer class are synchronized		2. The methods of StringBuilder class is not synchronized

Immutable:
----------
==> It means value of the object can not be changed by it self

Mutable:
----------
==> It means value of the object can be changed by it self


Wrapper Classes:
----------------
==> Each of Java's 8 primitive datatypes as a class and those classes are called Wrapper classes. because they wrap the data to an object
Primitive DataType					Reference DataType[Wrapper class]
---------------------------------------------------------------------
1. byte				--->            Byte
2. short			--->			Short
3. int				--->			Integer
4. long				--->			Long
5. float			--->			Float
6. double			---> 			Double
7. char				---> 			Character
8. boolean			--->			Boolean

==> The above wrapper classes are part of java.lang package

Constructor:
-----------
	public Integer(int); --> It is used to convert int to Integer
	
Method:
------
	public int intValue(); --> It is used to convert Integer to int
	public static String toHexString(int) --> It is used to convert decimal integer to HexaDecimal String
	public static String toOctalString(int) --> It is used to convert decimal integer to Octal String
	public static String toBinaryString(int) --> It is used to convert decimal integer to Binary String
	
	public static int parseInt(String) throws NumberFormatException;--> It is used to convert String into the integer format
	
Primitive type to Reference type								Reference type to Primitive type
--------------------------------------------------------------------------------------------------
int x=5;														Inetger ob =new Integer(5);
Integer ob1 = new Integer(x);									int x=ob.intValue();
s.o.p(ob1);

Auto boxing:
-----------
==> The process of converting from primitive type to corresponding reference type is known as Auto boxing

Auto Unboxing:
--------------
==> The process of converting reference type to corresponding primitive typ is known as Auto Unboxing
